# Huffman Compress

### Code Structure

为实现哈夫曼压缩编码，学生写下以下文件：
PQueue.h为学生自己写的优先级队列模板容器，以顺序结构构造优先级队列，优先级采用<和>判断，在Item数据类型中重载好优先级的比较符号；
HuffmanTree.h为学生自己写的哈夫曼树的结点和类定义，应用了PQueue作为HuffTree的private成员储存数据；
Compress.h储存了有关位操作的宏定义和两个与压缩解压缩有关的两个类：class潘霏霏和class万宇扬；
Compress.cpp是compress.h中两个类成员函数的实现；
Main.cpp为测试代码，可随意修改。

### Some Issues

在对题目的解答过程中主要遇到了三次难题：
1．	一开始对huffman树的结构架构错误。在早期的huffmantree定义中hufftreenode里只存放一个数据，将存放uchar与freq的结点分开，后来证明这种架构存在棘手问题，主要出现与模板嵌套在叶子节点与叶子节点的父节点间出现的模板不匹配问题。新版的hufffmannode采用单节点双数据模式，有效解决了问题。
2．	早期在对写入文件与读取文件方式上存在误解，早期逐字符读取逐字符写入（getchar和putchar）的想法尝试后被证明是低效且难以实现的，而且在储存哈夫曼编码的方式上没有按照位操作储存导致大量内存被耗费。后期采用了位操作以及按uchar8字节循环读取存储的模式有效解解决了问题。
这部分问题解决主要参考了网上的资料，这部分资料也提供了在解决储存哈夫曼编码模式问题上一些新想法https://www.cnblogs.com/evenleee/p/11932122.html,包括哈夫曼树在huff文件中的储存也是参考了这篇文章里面的设计。
3．	最后成品阶段出现了压缩包大小是源文件大小约20倍左右的问题。经过一天的艰难排查最终发现是我自己定义的优先级队列是最大优先级队列，微调优先级队列改为最小优先级队列后问题得到解决。

### How to use

以下是本程序的使用方法：
我为用户提供了两个接口，第一个是潘霏霏的唯一一个公有方法：小傻瓜()，用户在函数内先后输入未编码的文件名和编码后的文件名，运行程序，程序开始对未编码的文件进行压缩并输出编码后的文件。
另一个是万宇扬的唯一一个公有方法：大笨蛋()，用户在函数内先后输入未编码的文件名和编码后的文件名，运行程序，程序开始对已编码的文件进行压缩并输出未编码的文件。

如果感兴趣测试学生程序中的其他功能，请在main.h文件中的main函数中写下相应的代码，并运行测试！
